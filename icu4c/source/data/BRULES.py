# Copyright (C) 2016 and later: Unicode, Inc. and others.
# License & terms of use: http://www.unicode.org/copyright.html

from distutils.sysconfig import parse_makefile

from buildtool import *


def generate_index_file(locales, cldr_version, common_vars):
    formatted_version = "    CLDRVersion { \"%s\" }\n" % cldr_version if cldr_version else ""
    formatted_locales = "\n".join(["        %s {\"\"}" % v for v in locales])
    # TODO: CLDRVersion is required only in the base file
    return ("// Warning this file is automatically generated\n"
            "{INDEX_NAME}:table(nofallback) {{\n"
            "{FORMATTED_VERSION}"
            "    InstalledLocales {{\n"
            "{FORMATTED_LOCALES}\n"
            "    }}\n"
            "}}").format(FORMATTED_VERSION = formatted_version, FORMATTED_LOCALES = formatted_locales, **common_vars)


def get_all_output_files(requests):
    all_output_files = []
    for request in requests:
        if isinstance(request, SingleExecutionRequest):
            all_output_files += request.output_files
        elif isinstance(request, RepeatedExecutionRequest):
            all_output_files += request.output_files
        elif isinstance(request, PrintFileRequest):
            all_output_files += [request.output_file]

    # Filter out all files but those in OUT_DIR
    collected_files = (file for file in all_output_files if isinstance(file, OutFile))

    # Return a set with unique values
    return set(collected_files)


def generate(config, glob, common_vars):
    requests = []
    pkg_exclusions = set()

    # DIRECTORIES
    build_dirs = ["{OUT_DIR}", "{OUT_DIR}/curr", "{OUT_DIR}/lang", "{OUT_DIR}/region", "{OUT_DIR}/zone", "{OUT_DIR}/unit", "{OUT_DIR}/brkitr", "{OUT_DIR}/coll", "{OUT_DIR}/rbnf", "{OUT_DIR}/translit", "{TMP_DIR}", "{TMP_DIR}/curr", "{TMP_DIR}/lang", "{TMP_DIR}/locales", "{TMP_DIR}/region", "{TMP_DIR}/zone", "{TMP_DIR}/unit", "{TMP_DIR}/coll", "{TMP_DIR}/rbnf", "{TMP_DIR}/translit", "{TMP_DIR}/brkitr"]

    # UConv Name Aliases
    if config.has_feature("cnvalias"):
        input_file = InFile("mappings/convrtrs.txt")
        output_file = OutFile("cnvalias.icu")
        requests += [
            SingleExecutionRequest(
                name = "cnvalias",
                input_files = [input_file],
                output_files = [output_file],
                tool = IcuTool("gencnval"),
                args = "-d {OUT_DIR} {IN_DIR}/{INPUT_FILES[0]}",
                format_with = {}
            )
        ]

    # CONFUSABLES
    if config.has_feature("confusables"):
        txt1 = InFile("unidata/confusables.txt")
        txt2 = InFile("unidata/confusablesWholeScript.txt")
        cfu = OutFile("confusables.cfu")
        requests += [
            SingleExecutionRequest(
                name = "confusables",
                input_files = [txt1, txt2, OutFile("cnvalias.icu")],
                output_files = [cfu],
                tool = IcuTool("gencfu"),
                args = "-c -i {OUT_DIR} -r {IN_DIR}/{INPUT_FILES[0]} -w {IN_DIR}/{INPUT_FILES[1]} -o {OUT_DIR}/{OUTPUT_FILES[0]}",
                format_with = {}
            )
        ]

    # UConv Conversion Table Files
    if config.has_feature("uconv"):
        input_files = [InFile(filename) for filename in glob("mappings/*.ucm")]
        output_files = [OutFile("%s.cnv" % v.filename[9:-4]) for v in input_files]
        # TODO: handle BUILD_SPECIAL_CNV_FILES? Means to add --ignore-siso-check flag to makeconv
        if config.max_parallel():
            # Do each cnv file on its own
            requests += [
                RepeatedExecutionRequest(
                    name = "uconv",
                    dep_files = [],
                    input_files = input_files,
                    output_files = output_files,
                    tool = IcuTool("makeconv"),
                    args = "-c -d {OUT_DIR} {IN_DIR}/{INPUT_FILE}",
                    format_with = {},
                    repeat_with = {}
                )
            ]
        else:
            # Do all cnv files in one command
            # Faster overall but cannot be parallelized
            requests += [
                SingleExecutionRequest(
                    name = "uconv",
                    input_files = input_files,
                    output_files = output_files,
                    tool = IcuTool("makeconv"),
                    args = "-c -d {OUT_DIR} {INPUT_FILES_SPACED}",
                    format_with = {
                        "INPUT_FILES_SPACED": " ".join(file.filename for file in input_files)
                    }
                )
            ]

    # BRK Files
    brkitr_brk_files = []
    if config.has_feature("brkitr"):
        input_files = [InFile(filename) for filename in glob("brkitr/rules/*.txt")]
        output_files = [OutFile("brkitr/%s.brk" % v.filename[13:-4]) for v in input_files]
        brkitr_brk_files += output_files
        requests += [
            RepeatedExecutionRequest(
                name = "brkitr_brk",
                dep_files = [OutFile("cnvalias.icu")],
                input_files = input_files,
                output_files = output_files,
                tool = IcuTool("genbrk"),
                # TODO: Do we need the -d argument?
                args = "-c -i {OUT_DIR} -r {IN_DIR}/{INPUT_FILE} -o {OUT_DIR}/{OUTPUT_FILE}",
                format_with = {},
                repeat_with = {}
            )
        ]

    # SPP FILES
    if config.has_feature("stringprep"):
        input_files = [InFile(filename) for filename in glob("sprep/*.txt")]
        output_files = [OutFile("%s.spp" % v.filename[6:-4]) for v in input_files]
        bundle_names = [v.filename[6:-4] for v in input_files]
        requests += [
            RepeatedExecutionRequest(
                name = "stringprep",
                dep_files = [],
                input_files = input_files,
                output_files = output_files,
                tool = IcuTool("gensprep"),
                args = "-d {OUT_DIR} -i {OUT_DIR} -s {IN_DIR}/sprep -b {BUNDLE_NAME} -m {IN_DIR}/unidata -u 3.2.0 {BUNDLE_NAME}.txt",
                format_with = {},
                repeat_with = {
                    "BUNDLE_NAME": bundle_names
                }
            )
        ]

    # Dict Files
    dict_files = []
    if config.has_feature("dictionaries"):
        input_files = [InFile(filename) for filename in glob("brkitr/dictionaries/*.txt")]
        output_files = [OutFile("brkitr/%s.dict" % v.filename[20:-4]) for v in input_files]
        dict_files += output_files
        extra_options_map = {
            "brkitr/dictionaries/burmesedict.txt": "--bytes --transform offset-0x1000",
            "brkitr/dictionaries/cjdict.txt": "--uchars",
            "brkitr/dictionaries/khmerdict.txt": "--bytes --transform offset-0x1780",
            "brkitr/dictionaries/laodict.txt": "--bytes --transform offset-0x0e80",
            "brkitr/dictionaries/thaidict.txt": "--bytes --transform offset-0x0e00"
        }
        extra_optionses = [extra_options_map[v.filename] for v in input_files]
        requests += [
            RepeatedExecutionRequest(
                name = "dictionaries",
                dep_files = [],
                input_files = input_files,
                output_files = output_files,
                tool = IcuTool("gendict"),
                args = "{EXTRA_OPTIONS} -c -i {OUT_DIR} {IN_DIR}/{INPUT_FILE} {OUT_DIR}/{OUTPUT_FILE}",
                format_with = {},
                repeat_with = {
                    "EXTRA_OPTIONS": extra_optionses
                }
            )
        ]

    # NRM Files
    if config.has_feature("normalization"):
        input_files = [InFile(filename) for filename in glob("in/*.nrm")]
        input_files.remove(InFile("in/nfc.nrm"))  # nfc.nrm is pre-compiled into C++
        output_files = [OutFile(v.filename[3:]) for v in input_files]
        requests += [
            RepeatedExecutionRequest(
                name = "normalization",
                dep_files = [],
                input_files = input_files,
                output_files = output_files,
                tool = IcuTool("icupkg"),
                args = "-t{ICUDATA_CHAR} {IN_DIR}/{INPUT_FILE} {OUT_DIR}/{OUTPUT_FILE}",
                format_with = {},
                repeat_with = {}
            )
        ]

    # Collation Dependency File (ucadata.icu)
    if config.has_feature("coll"):
        input_file = InFile("in/coll/ucadata-%s.icu" % config.coll_han_type())
        output_file = OutFile("coll/ucadata.icu")
        requests += [
            SingleExecutionRequest(
                name = "coll_ucadata",
                input_files = [input_file],
                output_files = [output_file],
                tool = IcuTool("icupkg"),
                args = "-t{ICUDATA_CHAR} {IN_DIR}/{INPUT_FILES[0]} {OUT_DIR}/{OUTPUT_FILES[0]}",
                format_with = {}
            )
        ]

    # Unicode Character Names
    if config.has_feature("unames"):
        input_file = InFile("in/unames.icu")
        output_file = OutFile("unames.icu")
        requests += [
            SingleExecutionRequest(
                name = "unames",
                input_files = [input_file],
                output_files = [output_file],
                tool = IcuTool("icupkg"),
                args = "-t{ICUDATA_CHAR} {IN_DIR}/{INPUT_FILES[0]} {OUT_DIR}/{OUTPUT_FILES[0]}",
                format_with = {}
            )
        ]

    # Misc Data Res Files
    if config.has_feature("misc"):
        # TODO: Treat each misc file separately
        input_files = [InFile(filename) for filename in glob("misc/*.txt")]
        input_basenames = [v.filename[5:] for v in input_files]
        output_files = [OutFile("%s.res" % v[:-4]) for v in input_basenames]
        requests += [
            RepeatedExecutionRequest(
                name = "misc",
                dep_files = [],
                input_files = input_files,
                output_files = output_files,
                tool = IcuTool("genrb"),
                args = "-k -q -i {OUT_DIR} -s {IN_DIR}/misc -d {OUT_DIR} {INPUT_BASENAME}",
                format_with = {},
                repeat_with = {
                    "INPUT_BASENAME": input_basenames
                }
            )
        ]

    # Specialized Locale Data Res Files
    specialized_sub_dirs = [
        # (input dirname, output dirname, resfiles.mk path, mk version var, mk source var, use pool file, dep files)
        ("locales",  None,       "resfiles.mk",  "GENRB_CLDR_VERSION",     "GENRB_SOURCE",     True,
            []),
        ("curr",     "curr",     "resfiles.mk",  "CURR_CLDR_VERSION",      "CURR_SOURCE",      True,
            []),
        ("lang",     "lang",     "resfiles.mk",  "LANG_CLDR_VERSION",      "LANG_SOURCE",      True,
            []),
        ("region",   "region",   "resfiles.mk",  "REGION_CLDR_VERSION",    "REGION_SOURCE",    True,
            []),
        ("zone",     "zone",     "resfiles.mk",  "ZONE_CLDR_VERSION",      "ZONE_SOURCE",      True,
            []),
        ("unit",     "unit",     "resfiles.mk",  "UNIT_CLDR_VERSION",      "UNIT_SOURCE",      True,
            []),
        ("coll",     "coll",     "colfiles.mk",  "COLLATION_CLDR_VERSION", "COLLATION_SOURCE", False,
            [OutFile("coll/ucadata.icu"), OutFile("timezoneTypes.res"), OutFile("keyTypeData.res")]),
        ("brkitr",   "brkitr",   "brkfiles.mk",  "BRK_RES_CLDR_VERSION",   "BRK_RES_SOURCE",   False,
            brkitr_brk_files + dict_files),
        ("rbnf",     "rbnf",     "rbnffiles.mk", "RBNF_CLDR_VERSION",      "RBNF_SOURCE",      False,
            []),
        ("translit", "translit", "trnsfiles.mk", None,                     "TRANSLIT_SOURCE",  False,
            [])
    ]

    for sub_dir, out_sub_dir, resfile_name, version_var, source_var, use_pool_bundle, dep_files in specialized_sub_dirs:
        out_prefix = "%s/" % out_sub_dir if out_sub_dir else ""
        if config.has_feature(sub_dir):
            # TODO: Clean this up for translit
            if sub_dir == "translit":
                input_files = [InFile("translit/root.txt"), InFile("translit/en.txt"), InFile("translit/el.txt")]
            else:
                input_files = [InFile(filename) for filename in glob("%s/*.txt" % sub_dir)]
            input_basenames = [v.filename[len(sub_dir)+1:] for v in input_files]
            output_files = [OutFile("%s%s.res" % (out_prefix, v[:-4])) for v in input_basenames]
            if use_pool_bundle:
                input_pool_files = [OutFile("%spool.res" % out_prefix)]
                use_pool_bundle_option = "--usePoolBundle {OUT_DIR}/{OUT_PREFIX}"
                requests += [
                    SingleExecutionRequest(
                        name = "%s_pool_write" % sub_dir,
                        input_files = dep_files + input_files,
                        output_files = input_pool_files,
                        tool = IcuTool("genrb"),
                        args = "--writePoolBundle -k -i {OUT_DIR} -s {IN_DIR}/{IN_SUB_DIR} -d {OUT_DIR}/{OUT_PREFIX} {INPUT_BASENAMES_SPACED}",
                        format_with = {
                            "IN_SUB_DIR": sub_dir,
                            "OUT_PREFIX": out_prefix,
                            "INPUT_BASENAMES_SPACED": " ".join(input_basenames)
                        }
                    ),
                ]
            else:
                input_pool_files = []
                use_pool_bundle_option = ""
            if config.max_parallel():
                # Do each res file on its own
                requests += [
                    RepeatedExecutionRequest(
                        name = "%s_res" % sub_dir,
                        dep_files = dep_files + input_pool_files,
                        input_files = input_files,
                        output_files = output_files,
                        tool = IcuTool("genrb"),
                        args = use_pool_bundle_option + " -k -i {OUT_DIR} -s {IN_DIR}/{IN_SUB_DIR} -d {OUT_DIR}/{OUT_PREFIX} {INPUT_BASENAME}",
                        format_with = {
                            "IN_SUB_DIR": sub_dir,
                            "OUT_PREFIX": out_prefix
                        },
                        repeat_with = {
                            "INPUT_BASENAME": input_basenames,
                        }
                    )
                ]
            else:
                # Do all res files in one command
                # Faster overall but cannot be parallelized
                requests += [
                    SingleExecutionRequest(
                        name = "%s_res" % sub_dir,
                        input_files = dep_files + input_pool_files + input_files,
                        output_files = output_files,
                        tool = IcuTool("genrb"),
                        args = use_pool_bundle_option + " -k -i {OUT_DIR} -s {IN_DIR}/{IN_SUB_DIR} -d {OUT_DIR}/{OUT_PREFIX} {INPUT_BASENAMES_SPACED}",
                        format_with = {
                            "IN_SUB_DIR": sub_dir,
                            "OUT_PREFIX": out_prefix,
                            "INPUT_BASENAMES_SPACED": " ".join(input_basenames)
                        }
                    )
                ]
            # Generate index txt file
            if sub_dir != "translit":
                # TODO: Change .mk files to .py files so they can be loaded directly.
                # Reading these files as .py will be required for Bazel.
                mk_values = parse_makefile("{GLOB_DIR}/{IN_SUB_DIR}/{RESFILE_NAME}".format(IN_SUB_DIR = sub_dir, RESFILE_NAME = resfile_name, **common_vars))
                cldr_version = mk_values[version_var] if version_var and sub_dir == "locales" else None
                locales = [v[:-4] for v in mk_values[source_var].split()]
                pkg_exclusions |= set(output_files) - set(OutFile("%s%s.res" % (out_prefix, locale)) for locale in locales)
                index_file_txt = TmpFile("{IN_SUB_DIR}/{INDEX_NAME}.txt".format(IN_SUB_DIR = sub_dir, **common_vars))
                requests += [
                    PrintFileRequest(
                        name = "%s_index_txt" % sub_dir,
                        output_file = index_file_txt,
                        content = generate_index_file(locales, cldr_version, common_vars)
                    )
                ]
                # Generate index res file
                index_res_file = OutFile("{OUT_PREFIX}{INDEX_NAME}.res".format(OUT_PREFIX = out_prefix, **common_vars))
                requests += [
                    SingleExecutionRequest(
                        name = "%s_index_res" % sub_dir,
                        input_files = [index_file_txt],
                        output_files = [index_res_file],
                        tool = IcuTool("genrb"),
                        args = "-k -i {OUT_DIR} -s {TMP_DIR}/{IN_SUB_DIR} -d {OUT_DIR}/{OUT_PREFIX} {INDEX_NAME}.txt",
                        format_with = {
                            "IN_SUB_DIR": sub_dir,
                            "OUT_PREFIX": out_prefix
                        }
                    )
                ]

    # Finally, make the package.
    all_output_files = list(sorted(get_all_output_files(requests)))
    icudata_list_file = TmpFile("icudata.lst")
    icudata_inc_file = InFile("icupkg.inc")
    pkgdata_makefile_in = InFile("pkgdataMakefile.in")
    pkgdata_makefile = InFile("pkgdataMakefile")
    requests += [
        PrintFileRequest(
            name = "icudata_list",
            output_file = icudata_list_file,
            content = "\n".join(file.filename for file in all_output_files)
        ),
        # TODO
        # SingleExecutionRequest(
        #     name = "pkgdata_makefile",
        #     input_files = [pkgdata_makefile_in],
        #     output_files = [pkgdata_makefile],
        #     tool = SystemTool("make"),
        #     args = ""
        # ),
        # SingleExecutionRequest(
        #     name = "icudata_inc_file",
        #     input_files = [pkgdata_makefile],
        #     output_files = [icudata_inc_file],
        #     tool = SystemTool("make"),
        #     args = "-f {IN_DIR}/pkgdataMakefile",
        #     format_with = {}
        # ),
        # SingleExecutionRequest(
        #     name = "icudata_package",
        #     input_files = all_output_files + [icudata_list_file, icudata_inc_file],
        #     # TODO: This function produces more files besides this dat file
        #     output_files = [TmpFile("{ICUDATA_PLATFORM_NAME}.dat".format(**common_vars))],
        #     tool = IcuTool("pkgdata"),
        #     args = "-O {IN_DIR}/icupkg.inc -q -c -s {OUT_DIR} -d {PKG_DIR} -e {ICUDATA_ENTRY_POINT} -T {TMP_DIR} -p {ICUDATA_NAME} -m {PKGDATA_MODE} -r {SO_TARGET_VERSION} {PKGDATA_LIBNAME} {TMP_DIR}/icudata.lst",
        #     format_with = {}
        # )
    ]

    return (build_dirs, requests)



# icupkg.inc: pkgdataMakefile
# 	$(MAKE) -f pkgdataMakefile

# pkgdataMakefile:
# 	cd $(top_builddir) \
# 	&& CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status

# ifeq ($(PKGDATA_OPTS),)
# PKGDATA_OPTS = -O $(top_builddir)/data/icupkg.inc
# endif
# ifeq ($(PKGDATA_VERSIONING),)
# PKGDATA_VERSIONING = -r $(SO_TARGET_VERSION)
# endif

# PKGDATA_LIST = $(OUTTMPDIR)/icudata.lst

# PKGDATA = $(TOOLBINDIR)/pkgdata $(PKGDATA_OPTS) -q -c -s $(CURDIR)/out/build/$(ICUDATA_PLATFORM_NAME) -d $(ICUPKGDATA_OUTDIR)

# packagedata: icupkg.inc $(PKGDATA_LIST) build-local
# ifneq ($(ENABLE_STATIC),)
# ifeq ($(PKGDATA_MODE),dll)
# 	$(PKGDATA_INVOKE) $(PKGDATA) -e $(ICUDATA_ENTRY_POINT) -T $(TMP_DIR) -p $(ICUDATA_NAME) $(PKGDATA_LIBSTATICNAME) -m static $(PKGDATA_VERSIONING) $(PKGDATA_LIST)
# endif
# endif
# ifneq ($(ICUDATA_SOURCE_IS_NATIVE_TARGET),YES)
# 	$(PKGDATA_INVOKE) $(PKGDATA) -e $(ICUDATA_ENTRY_POINT) -T $(TMP_DIR) -p $(ICUDATA_NAME) -m $(PKGDATA_MODE) $(PKGDATA_VERSIONING) $(PKGDATA_LIBNAME) $(PKGDATA_LIST)
# else
# 	$(INSTALL_DATA) $(ICUDATA_SOURCE_ARCHIVE) $(OUTDIR)
# endif
# 	echo timestamp > $@




